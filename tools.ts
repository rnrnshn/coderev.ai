import { tool } from "ai";
import { simpleGit } from "simple-git";
import { z } from "zod";
import { writeFileSync } from "fs";

const excludeFiles = ["dist", "bun.lock"];

const fileChange = z.object({
  rootDir: z.string().min(1).describe("The root directory"),
});

type FileChange = z.infer<typeof fileChange>;

async function getFileChangesInDirectory({ rootDir }: FileChange) {
  const git = simpleGit(rootDir);
  const summary = await git.diffSummary();
  const diffs: { file: string; diff: string }[] = [];

  for (const file of summary.files) {
    if (excludeFiles.includes(file.file)) continue;
    const diff = await git.diff(["--", file.file]);
    diffs.push({ file: file.file, diff });
  }

  return diffs;
}

export const getFileChangesInDirectoryTool = tool({
  description: "Gets the code changes made in given directory",
  inputSchema: fileChange,
  execute: getFileChangesInDirectory,
});

// Commit message generation tool
const commitMessageSchema = z.object({
  rootDir: z.string().min(1).describe("The root directory to analyze for commit message"),
  style: z.enum(["conventional", "simple", "detailed"]).optional().describe("Commit message style").default("conventional"),
});

type CommitMessageInput = z.infer<typeof commitMessageSchema>;

async function generateCommitMessage({ rootDir, style }: CommitMessageInput) {
  const git = simpleGit(rootDir);
  const summary = await git.diffSummary();
  const stagedFiles = await git.diff(["--cached", "--name-only"]);
  
  if (!stagedFiles.trim()) {
    return "No staged changes found. Please stage your changes first using 'git add'.";
  }

  const changes = summary.files.filter(file => !excludeFiles.includes(file.file));
  
  if (changes.length === 0) {
    return "No significant changes found to generate a commit message.";
  }

  // Analyze the types of changes
  const addedFiles = changes.filter(f => 'insertions' in f && f.insertions > 0 && f.deletions === 0);
  const deletedFiles = changes.filter(f => 'insertions' in f && f.insertions === 0 && f.deletions > 0);
  const modifiedFiles = changes.filter(f => 'insertions' in f && f.insertions > 0 && f.deletions > 0);
  const renamedFiles = changes.filter(f => f.binary === false && f.file.includes("=>"));

  let message = "";

  if (style === "conventional") {
    // Generate conventional commit message
    if (addedFiles.length > 0 && modifiedFiles.length === 0 && deletedFiles.length === 0) {
      message = "feat: add new functionality";
    } else if (deletedFiles.length > 0 && addedFiles.length === 0 && modifiedFiles.length === 0) {
      message = "feat: remove deprecated functionality";
    } else if (modifiedFiles.length > 0) {
      message = "refactor: update existing functionality";
    } else {
      message = "chore: update codebase";
    }
  } else if (style === "simple") {
    const totalChanges = changes.reduce((sum, f) => {
      if ('insertions' in f && 'deletions' in f) {
        return sum + f.insertions + f.deletions;
      }
      return sum;
    }, 0);
    message = `Update ${changes.length} file${changes.length > 1 ? 's' : ''} (${totalChanges} changes)`;
  } else if (style === "detailed") {
    const details = [];
    if (addedFiles.length > 0) details.push(`+${addedFiles.length} new files`);
    if (modifiedFiles.length > 0) details.push(`~${modifiedFiles.length} modified files`);
    if (deletedFiles.length > 0) details.push(`-${deletedFiles.length} deleted files`);
    message = `Code changes: ${details.join(", ")}`;
  }

  // Add file names if there are few changes
  if (changes.length <= 3) {
    const fileNames = changes.map(f => f.file).join(", ");
    message += ` (${fileNames})`;
  }

  return message;
}

export const generateCommitMessageTool = tool({
  description: "Generates an appropriate commit message based on git changes in the directory",
  inputSchema: commitMessageSchema,
  execute: generateCommitMessage,
});

// Markdown review writing tool
const markdownReviewSchema = z.object({
  reviewContent: z.string().min(1).describe("The review content to write to markdown file"),
  outputPath: z.string().min(1).describe("The path where to save the markdown file"),
  title: z.string().optional().describe("Optional title for the review").default("Code Review"),
});

type MarkdownReviewInput = z.infer<typeof markdownReviewSchema>;

async function writeReviewToMarkdown({ reviewContent, outputPath, title }: MarkdownReviewInput) {
  const timestamp = new Date().toISOString();
  const markdownContent = `# ${title}

**Generated on:** ${timestamp}

---

${reviewContent}

---

*This review was generated by an AI code review agent.*
`;

  try {
    writeFileSync(outputPath, markdownContent, 'utf8');
    return `Review successfully written to ${outputPath}`;
  } catch (error) {
    return `Error writing review to file: ${error instanceof Error ? error.message : 'Unknown error'}`;
  }
}

export const writeReviewToMarkdownTool = tool({
  description: "Writes a code review to a markdown file with proper formatting",
  inputSchema: markdownReviewSchema,
  execute: writeReviewToMarkdown,
});
